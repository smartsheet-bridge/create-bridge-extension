---
id: function
title: Functions
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A "function" is a single unit of code that can be triggered by an external system. A function will execute with some inputs, and return an output.

<Tabs
groupId="js2ts"
defaultValue="js"
values={[
  { label: 'JavaScript', value: 'js', },
  { label: 'TypeScript', value: 'ts', },
]
}>
<TabItem value="js">


```js
export const myFunction = inputs => `Hello, ${inputs.username}`;
```

</TabItem>
<TabItem value="ts">


```ts
interface MyFunctionInputs {
  username: string;
}

export const myFunction: ExtensionFunction<MyFunctionInputs> = inputs =>
  `Hello, ${inputs.username}`;
```

</TabItem>
</Tabs>


## Function Parameters

An extension function always takes two parameters: `inputs`, and `context`.

### `inputs`

An extension defined, user-populated map of input parameters that are provided to the function at execution time.

```ts
type inputs = Record<string, any>;
```

:::warning User data

Each input parameter consists of user populated data and therefore should be treated with care. The extension handler will validate required properties for `undefined` or `null` values but you should **always assume that the input is unsafe**.

**Remember that user data may contain sensitive information** so please follow [logging best practices](../advanced/best_practices#logging).

:::

### `context`

An object that consists of metadata properties in the context of the triggering user and extension.

```ts
interface BridgeContext<T> {
  settings: T;
}
```

## Function Response

Returning a response from a Function is no different from returning a response from any other JavaScript function including returning [promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) and [thunks](https://en.wikipedia.org/wiki/Thunk).

### Primitives

Return a primitive value just as you would any other function.

```js
export const aStringResponse = () => 'a string response';

export const aNumberResponse = () => 42;

export const aBooleanResponse = () => true;
```

Objects and arrays are also returned as normal.

```js
export const anObjectResponse = () => ({ nested: { result: 42 } });

export function anArrayResponse() {
  const myArray = ['one', 'two', 'three'];
  return myArray;
}
```

### Promises

Promises will be executed and either fully resolved or rejected before eventually returning the response allowing you do write asynchronous extension functions as if they were synchronous.

```js
export const anResolvedResponse = () => Promise.resolve('a resolved promise');

export const anRejectedResponse = () => Promise.reject('a resolved promise');
```

Promises can also be chained.

```js
export const anChainedResponse = () =>
  axios
    .get('https://example.com/user?ID=12345')
    .then(function (response) {
      // handle success
      return response;
    })
    .catch(function (error) {
      // handle error
      return error;
    });
```

You can also write promises using the `async`/`await` syntax.

```js
export const async anAsyncResponse = () => {
  const response = await axios
    .get('https://example.com/user?ID=12345')
  return response;
}
```

### Thunks

If dealing with external libraries that make use of functions that require an async "callback" parameter, you can return a thunk. A thunk is a function that is returned by another. In this case the parameter of the thunk is a `respond` function that can be called when you are ready to return. Learn more about [Using Thunks](/advanced/thunks) in our advanced guide.

```js {4,6}
// Extension Function.
export const async thunkResponse = () => {
  // Thunk with respond parameter.
  return (respond) => {
    // Calling respond causes the extension to respond.
    respond('Hello, World')
  }
}
```

### Errors

:::warning

// TODO decide with the team how errors will be handled

:::

There's nothing special about Errors when writing an extension. Any error explicitly thrown or implicitly caught will be returned to the sender as a

```js
throw new Error('This will return an error');
```

will be received by the sender as

```
400
USER_ERROR
This will return an error
```
